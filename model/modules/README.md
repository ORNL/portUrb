# Main shared modules for portUrb simulations

For more information on a module, please see the individual module source file (`*.h`) itself and the comments therein. Some are classes that implement an `init` and a custom-named run function name. Some only implement a custom-named run function. Most accept the coupler object and time step size in their run functions, but some accept additional parameters.

Also, check out the `portUrb/experiments/examples` directory `*.cpp` files for examples of how to use the modules below.

* `helpers/`: Contains helper files, mainly for the dynamical core (`dynamics_rk_simpler.h`) for reconstruction (`TransformMatrices.h`), Weighted Essentially Non-Oscillatory reconstruction (`WenoLimiter.h`), and sagemath code to generate code for the reconstruction and WENO source files.
* `Betti_simplified.h`: Implements the `Floating_motions_betti` class to simulate floating turbine motions for the Tension Leg Platform of an NREL 5MW turbine using the equations and constants of "Development of a Control-Oriented Model of Floating Wind Turbines", Betti et al., 2014
* `column_nudging.h`: Implements the `ColumnNudger` class to set a column to nudge the entire coupler object's column toward and then nudge the coupler's average column toward that value according to a specified time scale.
* `dynamics_rk_simpler.h`: Implements the main dynamical core class `Dynamics_Euler_Stratified_WenoFV`, which performs 3-D compressible, non-hydrostatic, moist Euler equations of fluid dynamics without an LES closure or surface fluxes using high-order WENO interpolation for everything except momenta. Also the primary workhorse for inserting immersed boundaries. This also performs transport of mass-weighted tracer fields like water vapor, hydrometeors, SGS TKE, and other tracers registered with the dynamical core. The default order of accuracy is 9th-order. You'll want to have all tracers registered with the Coupler object before calling the dynamical core `init` function, which typically amounts to calling other modules' `init` functions before calling this class's `init` function. You'll want to allocate and initialize data before calling this class's `init` function, and you'll want to perform perturbations on the initial state *after* calling this function's `init` function. This uses a cell-centered upwind Finite-Volume method implemented on perturbations about a hydrostatic background state.
* `edge_sponge.h`: Implements the `EdgeSpone` class, which sets a column to nudge the horizontal edges of the simulation towards, and then has a function to nudge the horizontal edges of the domain toward the set column according to a time scale and domain lengths of nudging for each horizontal edge. 
* `fluctuation_scaling.h`: This will scale the fluctuations about the mean of the specified variables of a coupler object by the specified fraction by a time scale. This is primarily used to change turbulent precursor turbulent intensities to a smaller or higher value when feeding them into a forced simulation.
* `geostrophic_wind_forcing.h`: This implements a function to force the coupler object's horizontal winds with "geostrophic forcing" for atmospheric boundary layer simulations. This is a form of forcing akin to "pressure gradient forcing" except with an ekman spiral arising when used alongside surface friction. One can specify geostrophic forcing directly to a coupler object and then save the column forcing to apply identical forcing using a separate routine to a forced simulation from the direct forcing applied to a precursor coupler object.
* `hydrostasis.h`: This is not used directly during runtime but is, rather, only used during initialization to establish hydrostatic background states for a column using specified variables (either potential temperature profile or a combined specification of temperature and dry mixing ratio of water vapor). 
* `les_closure.h`: Implements the `LES_Closure` class, which implements the 1-equation Lilly closure to apply eddy viscosity to the coupler object's flow using a prognosed SGS TKE tracer. Please initialize this before the dynamical core so that the `TKE` tracer is registered.
* `microphysics_kessler.h`: Implements the `Microphysics_Kessler` class to apply simple 1-moment Kessler microphysics to the coupler object's flow. This introduces tracers, so please initialize this before initializing the dynamical core so that they are registered.
* `microphysics_morr.h`: Implements the `Microphysics_Morrison` class to apply Morrison 2-moment Kessler microphysics to the coupler object's flow. This introduces tracers, so please initialize this before initializing the dynamical core so that they are registered.
* `Mp_morr_two_moment.h`: This is a class used by `microphysics_morr.h` and not directly by the user, which actually implements the 2-moment code.
* `precursor_sponge.h`: This implements a function to sponge in a precursor coupler state onto a forced coupler state at horizontal edges according to a domain length for each horizontal edge as well as a time scale.
* `profiles.h`: This is used only during initialization to define various vertical profiles for initialization routines.
* `sponge_layer.h`: This implements a sponge layer function to force variables at the model top toward horizontally averaged values for u-velocity, v-velocity, and temperature and toward zero for w-velocity according to a specified top domain length and a time scale.
* `surface_cooling.h`: This implements a surface cooling function to cool the surface temperature of a coupler object by a given rate, typically used to implement stable atmospheric boundary layer simulations.
* `surface_flux.h`: The applies surface fluxes of momenta and temperature at the model surface and at immersed boundary surfaces using Monin-Obukhov Similarity Theory (MOST). 
* `surface_heat_flux.h`: This applies surface heat fluxes to the surface of a coupler object's data (it adds temperature to the surface layer but does not affect the surface temperature value), typically used to implement convective atmospheric boundary layer simulations.
* `time_averager.h`: This averages wind velocities and SGS TKE in time for time-averaged output variables.
* `TriMesh.h`: This is only used during initialization in order to process triangle-based OBJ wavefront files in order to determine heights of immersed material (typically buildings) for initialization of city simulations.
* `turbine_actuator_disc.h`: This implements an actuator disk for wind turbine simulations in the Large Eddy Simulation (LES) regime where the horizontal and vertcal grid spacing is significantly less than the width of a turbine diameter. These actuator disks yaw with the inflow and project a sampling disk 2 turbine diameters in the upwind direction for inflow sampling. You can place multiple turbines in the coupler domain. this applies turbine thrust to the flow, applies torque to the flow, and estimates generated power from the inflow wind speed, all using reference tables for a given turbine type.
* `turbine_fitch.h`: This implements a Fitch-type turbine parameterization for simulations where the horizontal grid spacing is significantly greater than the width of a turbine diameter. The vertical grid spacing can be finer than the turbine diameter, though. It applies thrust directly to the cells in which turbines are placed according to the proportion of the turbine in a given vertical cell, and it estimates power production based on the wind velocity of a cell. Multiple turbines can be placed with this parameterization.
* `uniform_pg_wind_forcing.h`: This implements pressure gradient wind forcing uniformly to the domain, which basically just penalizes differences from a target wind speed at a certain height according to a certain time scale. This can be applied directly to a precursor and the domain-averaged forcing be saved to be applied identically to a forced simulation that uses the precursor as well.
* `windmill_actuators_yaw.h`: This is similar to `turbine_actuator_disc.h`. It is for simulations where the horizontal and vertical grid spacings are significantly less than the width of a turbine diameter. Multiple turbines can be placed, but please do not place a turbine closer than two turbine diameters from the domain edge (just like the `turbine_actuator_disc.h` parameterization). This also allows the thrust to be projected onto rotating blades for very high-resolution simulations (say, at least 20 cells along a turbine diameter) rather than onto a disk, and it also allows projecting the turbine tower, hub, and flange as immersed material in the flow). This also allows floating platform forces to be added to the inflow of the turbine to emulate floating turbines.
